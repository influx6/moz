// Package osconv defines a function which runs through a giving directory and returns a Filesystem in return.
// Helps in converting filesystem files into a embeddable and usable format.
package osconv

import (
	"bytes"
	"errors"
	"io"
	"os"
	"path"
	"path/filepath"
	"runtime"

	"github.com/influx6/moz/gen"
	"github.com/influx6/moz/gen/filesystem"
)

// ConvertDir returns a filesystem.DirWriter structure for the giving directory path and its children.
// It runs through the directory and skips all paths that passes the filter functions only processing
// paths that do not.
// If `deferData` is set to true, it returns structures whoes files do not load their data into memory but wait
// till their `WriteTo` methods are called to improve memory usage.
func ConvertDir(dir string, deferData bool, filterFn func(string) bool) (filesystem.MemoryFileSystem, error) {
	files, dirs, err := readDir(dir, deferData, filterFn)
	if err != nil {
		return filesystem.MemoryFileSystem{}, err
	}

	var contents []interface{}
	contents = append(contents, filesystem.Version("1.0"), filesystem.Meta("path", dir),
		filesystem.Description("Autogenerated filesystem for %q", dir))

	fsm := filesystem.FileSystem(contents...)
	fsm.Dir.ChildFiles = append(fsm.Dir.ChildFiles, files...)
	fsm.Dir.ChildDirs = append(fsm.Dir.ChildDirs, dirs...)

	return fsm, nil
}

func readDir(path string, deferData bool, filterFn func(string) bool) ([]filesystem.FileWriter, []filesystem.DirWriter, error) {
	dir, err := os.Open(path)
	if err != nil {
		return nil, nil, err
	}

	dirInfo, err := dir.Stat()
	if err != nil {
		return nil, nil, err
	}

	if !dirInfo.IsDir() {
		return nil, nil, errors.New("Only directories allowed")
	}

	fileInfos, err := dir.Readdir(-1)
	if err != nil {
		return nil, nil, err
	}

	var files []filesystem.FileWriter
	var dirs []filesystem.DirWriter

	for _, info := range fileInfos {
		if !filterFn(filepath.Join(path, info.Name())) {
			continue
		}

		if info.IsDir() {
			subFiles, subDirs, err := readDir(filepath.Join(path, info.Name()), deferData, filterFn)
			if err != nil {
				return nil, nil, err
			}

			mainDir := filesystem.Dir(info.Name())
			mainDir.ChildDirs = append(mainDir.ChildDirs, subDirs...)
			mainDir.ChildFiles = append(mainDir.ChildFiles, subFiles...)

			dirs = append(dirs, mainDir)
			continue
		}

		if deferData {
			files = append(files, ConvertFile(filepath.Join(path, info.Name())))
			continue
		}

		dataFile, err := ConvertDataFile(filepath.Join(path, info.Name()))
		if err != nil {
			return nil, nil, err
		}

		files = append(files, dataFile)
	}

	return files, dirs, nil
}

// ConvertDataFile returns a filesystem.FileWriter structure for the giving file path with the data pulled in directly.
func ConvertDataFile(file string) (filesystem.FileWriter, error) {
	var filew filesystem.FileWriter

	var buf bytes.Buffer
	reader := FromFile{FilePath: file}
	if _, err := reader.WriteTo(&buf); err != nil {
		return filew, err
	}

	filew.Name = path.Base(file)
	filew.Content = &buf

	return filew, nil
}

// ConvertFile returns a filesystem.FileWriter structure for the giving file path with its data pull in later during its
// WriteTo call.
func ConvertFile(file string) filesystem.FileWriter {
	var filew filesystem.FileWriter
	filew.Name = path.Base(file)
	filew.Content = &FromFile{FilePath: file}
	return filew
}

//=======================================================================================================================================

// FromFile implements io.WriterTo by wrapping a provided file path which will be
// read into the provided writer.
type FromFile struct {
	FilePath string
}

// WriteTo implements io.WriterTo.
func (fm *FromFile) WriteTo(w io.Writer) (int64, error) {
	osFile, err := os.Open(fm.FilePath)
	if err != nil {
		return 0, err
	}

	defer osFile.Close()

	return (&gen.FromReader{R: osFile}).WriteTo(w)
}

//=======================================================================================================================================

var errStopWalking = errors.New("stop walking directory")

// DirWalker defines a function type which for processing a path and it's info
// retrieved from the fs.
type DirWalker func(rel string, abs string, info os.FileInfo) error

// WalkDir will run through the provided path which is expected to be a directory
// and runs the provided callback with the current path and FileInfo.
func WalkDir(dir string, callback DirWalker) error {
	isWin := runtime.GOOS == "windows"

	cerr := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		// If we got an error then stop and return it.
		if err != nil {
			return err
		}

		// If its a symlink, don't deal with it.
		if !info.Mode().IsRegular() {
			return nil
		}

		// If on windows, correct path slash.
		if isWin {
			path = filepath.ToSlash(path)
		}

		// Retrive relative path for giving path.
		relPath, err := filepath.Rel(dir, path)
		if err != nil {
			return err
		}

		// If false is return then stop walking and return errStopWalking.
		return callback(relPath, path, info)
	})

	// If we received error to stop walking then skip
	if cerr == errStopWalking {
		return nil
	}

	return cerr
}
