package annotations

import (
	"errors"
	"fmt"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/influx6/faux/fmtwriter"
	"github.com/influx6/moz"
	"github.com/influx6/moz/ast"
	"github.com/influx6/moz/gen"
)

var (
	_ = moz.RegisterAnnotation("templater", TemplaterAnnotationGenerator)
)

// TypeMap defines a map type of a giving series of key-value pairs.
type TypeMap map[string]string

// Get returns the value associated with the giving key.
func (t TypeMap) Get(key string) string {
	return t[key]
}

// TemplaterAnnotationGenerator defines a package level annotation generator which builds a go package in
// root of the package by using the content it receives from the annotation has a template for its output.
// package.
// Templater provides access to typenames by providing a "sel" function that gives you access to all
// arguments provided by the associated Annotation "templaterForTypes", which provides description of
// the filename, and the types to be used to replace the generic placeholders.
//
// Annotation: @templater
//
// Example:
// Create a template that uses the "Go" generator, identified with the id "Mob" which will
// generate template for all types with id of "Mob".
/*
@templater(id => Mob, gen => Go, {

  func Add(m {{sel TYPE1}}, n {{sel TYPE2}}) {{sel TYPE3}} {

  }

})
@templaterTypesFor(id => Mob, filename => bob_gen.go, TYPE1 => int32, TYPE2 => int32, TYPE3 => int64)
@templaterTypesFor(id => Mob, filename => bib_gen.go, TYPE1 => int, TYPE2 => int, TYPE3 => int64)
*/
func TemplaterAnnotationGenerator(toDir string, an ast.AnnotationDeclaration, pkg ast.PackageDeclaration) ([]gen.WriteDirective, error) {
	if len(an.Arguments) < 2 {
		return nil, errors.New("Expected 2 arguments as follows: 'id => IDOFTemplate, generator => Go'")
	}

	if an.Template == "" {
		return nil, errors.New("Expected Template from annotation")
	}

	var directives []gen.WriteDirective

	genName := strings.ToLower(an.Params["gen"])
	genID := strings.ToLower(an.Params["id"])

	for index, item := range pkg.AnnotationsFor("@templaterTypesFor") {
		if item.Params["id"] != an.Params["id"] {
			continue
		}

		fileName, ok := item.Params["filename"]
		if !ok {
			fileName = fmt.Sprintf("%s_%d.%s", genID, index, genName)
		}

		typeGen := gen.Block(gen.SourceTextWith(an.Template, template.FuncMap{
			"sel": TypeMap(item.Params).Get,
		}, struct {
			Params         TypeMap
			TypeParams     TypeMap
			TypeAnnotation ast.AnnotationDeclaration
			Package        ast.PackageDeclaration
			Annotation     ast.AnnotationDeclaration
		}{
			Package:        pkg,
			Annotation:     an,
			TypeAnnotation: item,
			Params:         TypeMap(an.Params),
			TypeParams:     TypeMap(item.Params),
		}))

		switch genName {
		case "partial.go":

			pkgGen := gen.Block(
				gen.Commentary(
					gen.Text("Autogenerated using the moz templater annotation."),
				),
				gen.Package(
					gen.Name(pkg.Package),
					typeGen,
				),
			)

			directives = append(directives, gen.WriteDirective{
				FileName: fileName,
				Dir:      filepath.Join(toDir),
				Writer:   fmtwriter.New(pkgGen, true, true),
			})

		case "go":
			directives = append(directives, gen.WriteDirective{
				FileName: fileName,
				Dir:      filepath.Join(toDir),
				Writer:   fmtwriter.New(typeGen, true, true),
			})

		default:
			directives = append(directives, gen.WriteDirective{
				Writer:   typeGen,
				FileName: fileName,
				Dir:      filepath.Join(toDir),
			})
		}
	}

	return directives, nil
}
