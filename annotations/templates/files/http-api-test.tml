var (
    events = metrics.New(stdout.Stdout{})
    version = "v1"
)

// TestGetAll{{.Struct.Object.Name}} validates the retrieval of a {{.Struct.Object.Name}} 
// record from httpapi.
func TestGetAll{{.Struct.Object.Name}}(t *testing.T){
	tree := httptreemux.New()

    db := NewMockAPIOperator()
	api := httpapi.New(events, db)

	// Register routes with router group.
	httpapi.RegisterRouteGroup(tree.NewGroup("/api"), api, version, "ignitors")

    elem, err := loadJSONFor({{lower .Struct.Object.Name.Name}}CreateJSON)
    if err != nil {
        tests.Failed("Should have successfully loaded JSON: {{lower .Struct.Object.Name.Name}}CreateJSON : %+q.", err)
    }
    tests.Passed("Should have successfully loaded JSON: {{lower .Struct.Object.Name.Name}}CreateJSON.")

    ctx := context.New()
    
    elem, err = db.Create(ctx, elem)
    if err != nil {
        tests.Failed("Should have successfully saved {{.Struct.Object.Name}} record : %+q.", err)
    }
    tests.Passed("Should have successfully saved {{.Struct.Object.Name}} record.")

    req, err := http.NewRequest("GET", fmt.Sprintf("api/%s/ignitors", version), nil)
    if err != nil {
        tests.Failed("Should have successfully created request {{.Struct.Object.Name}} record : %+q.", err)
    }
    tests.Passed("Should have successfully created request {{.Struct.Object.Name}} record.")

    res := httptest.NewRecorder()

    tree.ServeHTTP(res, req)

    if res.Code != http.StatusOK {
        tests.Failed("Should have received status code %d from response.", res.Code)
    }
    tests.Passed("Should have received status code %d from response.", http.StatusOK)

    if res.Body.Len() == 0 {
        tests.Failed("Should have successfully received response body.")
    }
    tests.Passed("Should have successfully received response body.")
}

// TestGet{{.Struct.Object.Name}} validates the retrieval of all {{.Struct.Object.Name}} 
// record from a httpapi.
func TestGet{{.Struct.Object.Name}}(t *testing.T){
	tree := httptreemux.New()

    db := NewMockAPIOperator()
	api := httpapi.New(events, db)

	// Register routes with router group.
	httpapi.RegisterRouteGroup(tree.NewGroup("/api"), api, version, "ignitors")

    elem, err := loadJSONFor({{lower .Struct.Object.Name.Name}}CreateJSON)
    if err != nil {
        tests.Failed("Should have successfully loaded JSON: {{lower .Struct.Object.Name.Name}}CreateJSON : %+q.", err)
    }
    tests.Passed("Should have successfully loaded JSON: {{lower .Struct.Object.Name.Name}}CreateJSON.")

    ctx := context.New()
    
    elem, err = db.Create(ctx, elem)
    if err != nil {
        tests.Failed("Should have successfully saved {{.Struct.Object.Name}} record : %+q.", err)
    }
    tests.Passed("Should have successfully saved {{.Struct.Object.Name}} record.")

    req, err := http.NewRequest("GET", fmt.Sprintf("api/%s/ignitors/%s", version, elem.PublicID), nil)
    if err != nil {
        tests.Failed("Should have successfully created request {{.Struct.Object.Name}} record : %+q.", err)
    }
    tests.Passed("Should have successfully created request {{.Struct.Object.Name}} record.")

    res := httptest.NewRecorder()

    tree.ServeHTTP(res, req)

    if res.Code != http.StatusOK {
        tests.Failed("Should have received status code %d from response.", res.Code)
    }
    tests.Passed("Should have received status code %d from response.", http.StatusOK)

    if res.Body.Len() == 0 {
        tests.Failed("Should have successfully received response body.")
    }
    tests.Passed("Should have successfully received response body.")
}

// Test{{.Struct.Object.Name}}Create validates the creation of a {{.Struct.Object.Name}} 
// record with a httpapi.
func Test{{.Struct.Object.Name}}Create(t *testing.T){
	tree := httptreemux.New()

    db := NewMockAPIOperator()
	api := httpapi.New(events, db)

	// Register routes with router group.
	httpapi.RegisterRouteGroup(tree.NewGroup("/api"), api, version, "ignitors")

    var body bytes.Buffer
    body.WriteString({{lower .Struct.Object.Name.Name}}CreateJSON)
    
    req, err := http.NewRequest("POST", fmt.Sprintf("api/%s/ignitors", version), &body)
    if err != nil {
        tests.Failed("Should have successfully created request {{.Struct.Object.Name}} record : %+q.", err)
    }
    tests.Passed("Should have successfully created request {{.Struct.Object.Name}} record.")

    res := httptest.NewRecorder()

    tree.ServeHTTP(res, req)

    if res.Code != http.StatusCreated {
        tests.Failed("Should have received status code %d from response.", res.Code)
    }
    tests.Passed("Should have received status code %d from response.", http.StatusCreated)

    if res.Body.Len() == 0 {
        tests.Failed("Should have successfully received response body.")
    }
    tests.Passed("Should have successfully received response body.")
}

// Test{{.Struct.Object.Name}}Update validates the update of a {{.Struct.Object.Name}} 
// record with a httpapi.
func Test{{.Struct.Object.Name}}Update(t *testing.T){
	tree := httptreemux.New()

    db := NewMockAPIOperator()
	api := httpapi.New(events, db)

	// Register routes with router group.
	httpapi.RegisterRouteGroup(tree.NewGroup("/api"), api, version, "ignitors")

    var body bytes.Buffer
    body.WriteString({{lower .Struct.Object.Name.Name}}CreateJSON)
    
    req, err := http.NewRequest("POST", fmt.Sprintf("api/%s/ignitors", version), &body)
    if err != nil {
        tests.Failed("Should have successfully created request {{.Struct.Object.Name}} record : %+q.", err)
    }
    tests.Passed("Should have successfully created request {{.Struct.Object.Name}} record.")

    res := httptest.NewRecorder()

    tree.ServeHTTP(res, req)

    if res.Code != http.StatusCreated {
        tests.Failed("Should have received status code %d from response.", res.Code)
    }
    tests.Passed("Should have received status code %d from response.", http.StatusCreated)

    if res.Body.Len() == 0 {
        tests.Failed("Should have successfully received response body.")
    }
    tests.Passed("Should have successfully received response body.")

    elem, err := loadJSONFor(res.Body.String())
    if err != nil {
        tests.Failed("Should have successfully loaded JSON:  %+q.", err)
    }
    tests.Passed("Should have successfully loaded JSON.")

    {{ randField .Struct "elem" "json" "public_id" }}

    var bu bytes.Buffer

    if err := json.NewEncoder(&bu).Encode(elem); err != nil {
        tests.Failed("Should have successfully encoded {{.Struct.Object.Name}}:  %+q.", err)
    }
    tests.Passed("Should have successfully encoded {{.Struct.Object.Name}}.")

    req, err = http.NewRequest("PUT", fmt.Sprintf("api/%s/ignitors/%s", version, elem.PublicID), &body)
    if err != nil {
        tests.Failed("Should have successfully created request {{.Struct.Object.Name}} record : %+q.", err)
    }
    tests.Passed("Should have successfully created request {{.Struct.Object.Name}} record.")

    res = httptest.NewRecorder()

    tree.ServeHTTP(res, req)

    if res.Code != http.StatusNoContent {
        tests.Failed("Should have received status code %d from response.", res.Code)
    }
    tests.Passed("Should have received status code %d from response.", http.StatusNoContent)
}

// Test{{.Struct.Object.Name}}Delete validates the removal of a {{.Struct.Object.Name}} 
// record from a httpapi.
func Test{{.Struct.Object.Name}}Delete(t *testing.T){
	tree := httptreemux.New()

    db := NewMockAPIOperator()
	api := httpapi.New(events, db)

	// Register routes with router group.
	httpapi.RegisterRouteGroup(tree.NewGroup("/api"), api, version, "ignitors")

    elem, err := loadJSONFor({{lower .Struct.Object.Name.Name}}CreateJSON)
    if err != nil {
        tests.Failed("Should have successfully loaded JSON: {{lower .Struct.Object.Name.Name}}CreateJSON : %+q.", err)
    }
    tests.Passed("Should have successfully loaded JSON: {{lower .Struct.Object.Name.Name}}CreateJSON.")

    ctx := context.New()
    
    elem, err = db.Create(ctx, elem)
    if err != nil {
        tests.Failed("Should have successfully saved {{.Struct.Object.Name}} record : %+q.", err)
    }
    tests.Passed("Should have successfully saved {{.Struct.Object.Name}} record.")

    req, err := http.NewRequest("DELETE", fmt.Sprintf("api/%s/ignitors/%s", version, elem.PublicID), nil)
    if err != nil {
        tests.Failed("Should have successfully created request {{.Struct.Object.Name}} record : %+q.", err)
    }
    tests.Passed("Should have successfully created request {{.Struct.Object.Name}} record.")

    res := httptest.NewRecorder()

    tree.ServeHTTP(res, req)

    if res.Code != http.StatusNoContent {
        tests.Failed("Should have received status code %d from response.", res.Code)
    }
    tests.Passed("Should have received status code %d from response.", http.StatusNoContent)
}