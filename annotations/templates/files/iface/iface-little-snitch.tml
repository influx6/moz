{{$InterfaceName := .InterfaceName }}

{{ range .Methods }}
// MethodCallFor{{.Name}} defines a type which holds meta-details about the giving calls associated
// with the {{$InterfaceName}}.{{.Name}}() method.
type MethodCallFor{{.Name}} struct{
    When time.Time
    Start time.Time
    End time.Time

    // Details of panic if such occurs.
    PanicStack []byte
    PanicError interface{}

    // Argument values.
    {{ range .Args }}
    {{capitalize .Name}} {{.ExType}}
    {{end}}

    // Return values.
    {{ range .Returns }}
    {{capitalize .Name}} {{.ExType}}
    {{ end}}
}
{{ end }}

// {{.InterfaceName}}Snitch is an implementation of the {{.InterfaceName}} which will wrap the
// {{.InterfaceName}}Impl and allow you to record all arguments and return values from calls to the
// provided implementation which it wraps.
type {{.InterfaceName}}LittleSnitch struct{
    Implementer {{.Package.Package}}.{{.InterfaceName}}
    {{ range .Methods }}
    {{.Name}}MethodCalls []MethodCallFor{{.Name}}
    {{ end }}
}

// NewLittleSnitch returns a new instance of a {{.InterfaceName}}LittleSnitch for recording.
func NewLittleSnitch(impl {{.Package.Package}}.{{.InterfaceName}}) *{{.InterfaceName}}LittleSnitch {
    var snitch {{.InterfaceName}}LittleSnitch
    {{ range .Methods }}
    snitch.{{.Name}}MethodCalls = make([]MethodCallFor{{.Name}}, 0)
    {{ end }}

    return &snitch
}

{{ range .Methods }}
// {{.Name}} implements the {{$InterfaceName}}.{{.Name}}() method for the {{$InterfaceName}}.
func (impl *{{$InterfaceName}}LittleSnitch) {{.Name}}({{.ArgumentList true}}) ({{.ReturnList true}}){
    var caller MethodCallFor{{.Name}}

    defer func(){
        if err := recover(); err != nil {
            trace := make([]byte, 1000)
            trace = trace[:runtime.Stack(trace, all)]

            caller.PanicError = err
            caller.PanicStack = trace
        }

        caller.End = time.Now()
        impl.{{.Name}}MethodCalls = append(impl.{{.Name}}MethodCalls, caller)
    }()

    caller.When = time.Now()
    caller.Start = caller.When

    {{ range .Args }}
    caller.{{capitalize .Name}} = {{.Name}}
    {{ end }}

    {{.ReturnNamesList}} := impl.Implementer.{{.Name}}({{.ArgumentNamesList}})

    {{ range .Returns }}
    caller.{{capitalize .Name}} = {{.Name}}
    {{ end }}

    return {{.ReturnNamesList}}
}
{{ end }}

//==============================================================================================================

// {{.InterfaceName}}MockSnitch defines a function type which implements a struct with the
// methods for the {{.InterfaceName}} as fields which allows you provide implementations of
// these functions to provide flexible testing.
type {{.InterfaceName}}MockSnitch struct{
    {{ range .Methods }}
    {{.Name}}MethodCalls []MethodCallFor{{.Name}}
    {{.Name}}Func func({{.ArgumentList true}}) ({{.ReturnList true}})
    {{ end }}
}

{{ range .Methods }}
// {{.Name}} implements the {{$InterfaceName}}.{{.Name}}() method for the {{$InterfaceName}}.
func (impl *{{$InterfaceName}}MockSnitch) {{.Name}}({{.ArgumentList true}}) ({{.ReturnList true}}){
    var caller MethodCallFor{{.Name}}

    defer func(){
        if err := recover(); err != nil {
            trace := make([]byte, 1000)
            trace = trace[:runtime.Stack(trace, all)]

            caller.PanicError = err
            caller.PanicStack = trace
        }

        caller.End = time.Now()
        impl.{{.Name}}MethodCalls = append(impl.{{.Name}}MethodCalls, caller)
    }()

    caller.When = time.Now()
    caller.Start = caller.When

    {{ range .Args }}
    caller.{{capitalize .Name}} = {{.Name}}
    {{ end }}

    {{.ReturnNamesList}} := impl.{{.Name}}Func({{.ArgumentNamesList}})

    {{ range .Returns }}
    caller.{{capitalize .Name}} = {{.Name}}
    {{ end }}

    return {{.ReturnNamesList}}
}
{{ end }}
