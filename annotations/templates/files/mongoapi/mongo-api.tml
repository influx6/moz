// {{.Struct.Object.Name}}Fields defines an interface which exposes method to return a map of all 
// attributes associated with the defined structure as decided by the structure.
type {{.Struct.Object.Name}}Fields  interface {
	Fields() map[string]interface{}
}

// {{.Struct.Object.Name}}BSON defines an interface which exposes method to return a bson.M type
// which contains all related fields for the giving  object. 
type {{.Struct.Object.Name}}BSON interface {
	BSON() bson.M 
}

// {{.Struct.Object.Name}}BSONConsumer defines an interface which accepts a map of data which will be consumed
// into the giving implementing structure as decided by the structure.
type {{.Struct.Object.Name}}BSONConsumer interface {
	BSONConsume(bson.M) error
}

// {{.Struct.Object.Name}}Consumer defines an interface which accepts a map of data which will be consumed
// into the giving implementing structure as decided by the structure.
type {{.Struct.Object.Name}}Consumer interface {
	Consume(map[string]interface{}) error
}

// Mongod defines a interface which exposes a method for retrieving a
// mongo.Database and mongo.Session.
type Mongod interface {
	New() (*mgo.Database, *mgo.Session, error)
}

// {{.Struct.Object.Name}}DB defines a structure which provide DB CRUD operations 
// using mongo as the underline db.
type {{.Struct.Object.Name}}DB struct{
  col string
  db Mongod
  metrics metrics.Metrics   
}

// New returns a new instance of {{.Struct.Object.Name}}DB.
func New(col string, m metrics.Metrics,  mo Mongod) *{{.Struct.Object.Name}}DB{
    return &{{.Struct.Object.Name}}DB{
        db: mo,
        col: col,
        metrics: m,
    }
}

// Delete attempts to remove the record from the db using the provided publicID.
// Records using this DB must have a public id value, expressed either by a bson or json tag 
// on the given {{.Struct.Package}}.{{.Struct.Object.Name}} struct.
func (mdb *{{.Struct.Object.Name}}DB) Delete(ctx context.Context, publicID string) error {
    m := stdout.Info("{{.Struct.Object.Name}}DB.Delete").With("publicID", publicID).Trace("{{.Struct.Object.Name}}DB.Delete")
    defer mdb.metrics.Emit(m.End())

    if ctx.IsExpired() {
        err := fmt.Errorf("Context has expired")
        mdb.metrics.Emit(stdout.Error("Failed to delete record").With("publicID", publicID).With("error", err.Error()))
        return err
    }

    database, session, err := mdb.db.New()
    if err != nil {
        mdb.metrics.Emit(stdout.Error("Failed to delete record").With("publicID", publicID).With("error", err.Error()))
        return err
    }

    defer session.Close()

    query := bson.M{
        "publicID": publicID,
    }

    if ctx.IsExpired() {
        err := fmt.Errorf("Context has expired")
        mdb.metrics.Emit(stdout.Error("Failed to delete record").With("publicID", publicID).With("error", err.Error()))
        return err
    }

    if err := database.C(mdb.col).Remove(query); err != nil {
        mdb.metrics.Emit(stdout.Error("Failed to delete record").
        With("query", query).
        With("publicID", publicID).With("error", err.Error()))
        return err
    }

    mdb.metrics.Emit(stdout.Notice("Deleted record").
    With("query", query).
    With("publicID", publicID).With("error", err.Error()))

    return nil
}

// Create attempts to add the record into the db using the provided instance of the 
// {{.Struct.Package}}.{{.Struct.Object.Name}}.
// Records using this DB must have a public id value, expressed either by a bson or json tag 
// on the given {{.Struct.Object.Name}} struct.
func (mdb *{{.Struct.Object.Name}}DB) Create(ctx context.Context, elem {{.Struct.Package}}.{{.Struct.Object.Name}}) error {
    m := stdout.Info("{{.Struct.Object.Name}}DB.Create").With("publicID", elem.PublicID).Trace("{{.Struct.Object.Name}}DB.Create")
    defer mdb.metrics.Emit(m.End())

    if ctx.IsExpired() {
        err := fmt.Errorf("Context has expired")
        mdb.metrics.Emit(stdout.Error("Failed to create record").With("publicID", elem.PublicID).With("error", err.Error()))
        return err
    }

    database, session, err := mdb.db.New()
    if err != nil {
        mdb.metrics.Emit(stdout.Error("Failed to delete record").With("publicID", elem.PublicID).With("error", err.Error()))
        return err
    }

    defer session.Close()

    if ctx.IsExpired() {
        err := fmt.Errorf("Context has expired")
        mdb.metrics.Emit(stdout.Error("Failed to create record").With("publicID", elem.PublicID).With("error", err.Error()))
        return err
    }

    if fields, ok := interface{}(elem).({{.Struct.Object.Name}}BSON); ok {
        if err := database.C(mdb.col).Insert(fields.BSON()); err != nil {
            mdb.metrics.Emit(stdout.Error("Failed to create {{.Struct.Object.Name}} record").
            With("elem", elem).
            With("error", err.Error()))
            return err
        }

        mdb.metrics.Emit(stdout.Notice("Create record").
            With("elem", elem).
        With("error", err.Error()))

        return nil
    }

    if fields, ok := interface{}(elem).({{.Struct.Object.Name}}Fields); ok {
        if err := database.C(mdb.col).Insert(bson.M(fields.Fields())); err != nil {
            mdb.metrics.Emit(stdout.Error("Failed to create {{.Struct.Object.Name}} record").
            With("elem", elem).
            With("error", err.Error()))
            return err
        }

        mdb.metrics.Emit(stdout.Notice("Create record").
        With("elem", elem).
        With("error", err.Error()))

        return nil
    }

    query := bson.M({{ map .CreateAction "elem" "bson" "json" }})

    if ctx.IsExpired() {
        err := fmt.Errorf("Context has expired")
        mdb.metrics.Emit(stdout.Error("Failed to create record").With("publicID", elem.PublicID).With("error", err.Error()))
        return err
    }

    if err := database.C(mdb.col).Insert(query); err != nil {
        mdb.metrics.Emit(stdout.Error("Failed to create {{.Struct.Object.Name}} record").
        With("query", query).
        With("error", err.Error()))
        return err
    }

    mdb.metrics.Emit(stdout.Notice("Create record").
    With("query", query).
    With("error", err.Error()))

    return nil
}

// GetAll retrieves all records from the db and returns a slice of {{.Struct.Package}}.{{.Struct.Object.Name}} type.
// Records using this DB must have a public id value, expressed either by a bson or json tag 
// on the given {{.Struct.Object.Name}} struct.
func (mdb *{{.Struct.Object.Name}}DB) GetAll(ctx context.Context)  ([]{{.Struct.Package}}.{{.Struct.Object.Name}},  error) {
    m := stdout.Info("{{.Struct.Object.Name}}DB.GetAll").Trace("{{.Struct.Object.Name}}DB.GetAll")
    defer mdb.metrics.Emit(m.End())

    if ctx.IsExpired() {
        err := fmt.Errorf("Context has expired")
        mdb.metrics.Emit(stdout.Error("Failed to retrieve record").With("error", err.Error()))
        return nil, err
    }

    database, session, err := mdb.db.New()
    if err != nil {
        mdb.metrics.Emit(stdout.Error("Failed to delete record").With("error", err.Error()))
        return nil, err
    }

    defer session.Close()

    if ctx.IsExpired() {
        err := fmt.Errorf("Context has expired")
        mdb.metrics.Emit(stdout.Error("Failed to retrieve record").With("error", err.Error()))
        return nil, err
    }

    query := bson.M{}

    {{ if ( hasFunc .Struct "Consume"  ) }}

        var items []map[string]interface{}

        if err := database.C(mdb.col).Find(query).All(&items); err != nil {
            mdb.metrics.Emit(stdout.Error("Failed to retrieve all records of {{.Struct.Object.Name}} type from db").
            With("query", query).
            With("error", err.Error()))

            return nil, err
        }

        var ritems []{{.Struct.Package}}.{{.Struct.Object.Name}}

        for _, item := range items {
            var elem {{.Struct.Package}}.{{.Struct.Object.Name}}

            if err := elem.Consume(item); err != nil {
                return nil, err
            }

            ritems = append(ritems, elem)
        }

        return ritems, nil
    {{ else if ( hasFunc .Struct "BSONConsume"  ) }}
        var items []bson.M

        if err := database.C(mdb.col).Find(query).All(&items); err != nil {
            mdb.metrics.Emit(stdout.Error("Failed to retrieve all records of {{.Struct.Object.Name}} type from db").
            With("query", query).
            With("error", err.Error()))

            return nil, err
        }

        var ritems []{{.Struct.Package}}.{{.Struct.Object.Name}}

        for _, item := range items {
            var elem {{.Struct.Package}}.{{.Struct.Object.Name}}

            if err := elem.BSONConsume(item); err != nil {
                return nil, err
            }

            ritems = append(ritems, elem)
        }

        return ritems, nil
    {{ else }}

        var items []{{.Struct.Package}}.{{.Struct.Object.Name}}

        if err := database.C(mdb.col).Find(query).All(&items); err != nil {
            mdb.metrics.Emit(stdout.Error("Failed to retrieve all records of {{.Struct.Object.Name}} type from db").
            With("query", query).
            With("error", err.Error()))

            return nil, err
        }

        return items, nil
    {{ end }}
}

// Get retrieves a record from the db using the publicID and returns the {{.Struct.Package}}.{{.Struct.Object.Name}} type.
// Records using this DB must have a public id value, expressed either by a bson or json tag 
// on the given {{.Struct.Object.Name}} struct.
func (mdb *{{.Struct.Object.Name}}DB) Get(ctx context.Context, publicID string)  ({{.Struct.Package}}.{{.Struct.Object.Name}},  error) {
    m := stdout.Info("{{.Struct.Object.Name}}DB.Get").With("publicID", publicID).Trace("{{.Struct.Object.Name}}DB.Get")
    defer mdb.metrics.Emit(m.End())

    if ctx.IsExpired() {
        err := fmt.Errorf("Context has expired")
        mdb.metrics.Emit(stdout.Error("Failed to retrieve record").With("publicID", publicID).With("error", err.Error()))
        return {{.Struct.Package}}.{{.Struct.Object.Name}}{}, err
    }

    database, session, err := mdb.db.New()
    if err != nil {
        mdb.metrics.Emit(stdout.Error("Failed to delete record").With("publicID", publicID).With("error", err.Error()))
        return {{.Struct.Package}}.{{.Struct.Object.Name}}{}, err
    }

    defer session.Close()

    if ctx.IsExpired() {
        err := fmt.Errorf("Context has expired")
        mdb.metrics.Emit(stdout.Error("Failed to retrieve record").With("publicID", publicID).With("error", err.Error()))
        return {{.Struct.Package}}.{{.Struct.Object.Name}}{}, err
    }

    query := bson.M{"public_id": publicID}

    {{ if ( hasFunc .Struct "Consume"  ) }}
        var item map[string]interface{}

        if err := database.C(mdb.col).Find(query).One(&item); err != nil {
            mdb.metrics.Emit(stdout.Error("Failed to retrieve all records of {{.Struct.Object.Name}} type from db").
            With("query", query).
            With("error", err.Error()))

        return {{.Struct.Package}}.{{.Struct.Object.Name}}{}, err
        }

        var elem {{.Struct.Package}}.{{.Struct.Object.Name}}

        if err := elem.Consume(item); err != nil {
        return {{.Struct.Package}}.{{.Struct.Object.Name}}{}, err
        }

        return elem, nil

    {{ else if ( hasFunc .Struct "BSONConsume"  ) }}
        var itemBSON bson.M

        if err := database.C(mdb.col).Find(query).One(&itemBSON); err != nil {
            mdb.metrics.Emit(stdout.Error("Failed to retrieve all records of {{.Struct.Object.Name}} type from db").
            With("query", query).
            With("error", err.Error()))

        return {{.Struct.Package}}.{{.Struct.Object.Name}}{}, err
        }

        var item {{.Struct.Package}}.{{.Struct.Object.Name}}

        if err := elem.BSONConsume(itemBSON); err != nil {
            return {{.Struct.Package}}.{{.Struct.Object.Name}}{}, err
        }

        return item, nil
    {{ else }}

        var item {{.Struct.Package}}.{{.Struct.Object.Name}}

        if err := database.C(mdb.col).Find(query).One(&item); err != nil {
            mdb.metrics.Emit(stdout.Error("Failed to retrieve all records of {{.Struct.Object.Name}} type from db").
            With("query", query).
            With("error", err.Error()))

            return {{.Struct.Package}}.{{.Struct.Object.Name}}{}, err
        }

        return item, nil
    {{ end }}
}


// Update uses a record from the db using the publicID and returns the {{.Struct.Package}}.{{.Struct.Object.Name}} type.
// Records using this DB must have a public id value, expressed either by a bson or json tag 
// on the given {{.Struct.Object.Name}} struct.
func (mdb *{{.Struct.Object.Name}}DB) Update(ctx context.Context, publicID string, elem {{.Struct.Package}}.{{.Struct.Object.Name}}) error {
    m := stdout.Info("{{.Struct.Object.Name}}DB.Update").With("publicID", publicID).Trace("{{.Struct.Object.Name}}DB.Update")
    defer mdb.metrics.Emit(m.End())

    if ctx.IsExpired() {
        err := fmt.Errorf("Context has expired")
        mdb.metrics.Emit(stdout.Error("Failed to update record").With("publicID", publicID).With("error", err.Error()))
        return err
    }

    database, session, err := mdb.db.New()
    if err != nil {
        mdb.metrics.Emit(stdout.Error("Failed to update record").With("publicID", publicID).With("error", err.Error()))
        return err
    }

    defer session.Close()

    if ctx.IsExpired() {
        err := fmt.Errorf("Context has expired")
        mdb.metrics.Emit(stdout.Error("Failed to update record").With("publicID", publicID).With("error", err.Error()))
        return err
    }

    if fields, ok := interface{}(elem).({{.Struct.Object.Name}}BSON); ok {
        query := fields.BSON()

        if err := database.C(mdb.col).Insert(query); err != nil {
            mdb.metrics.Emit(stdout.Error("Failed to update {{.Struct.Object.Name}} record").
            With("query", query).
            With("error", err.Error()))

            return err
        }

        mdb.metrics.Emit(stdout.Notice("Update record").
        With("query", query).
        With("error", err.Error()))

        return nil
    }

    if fields, ok := interface{}(elem).({{.Struct.Object.Name}}Fields); ok {
        query := bson.M(fields.Fields())

        if err := database.C(mdb.col).Insert(query); err != nil {
            mdb.metrics.Emit(stdout.Error("Failed to update {{.Struct.Object.Name}} record").
            With("query", query).
            With("error", err.Error()))
            return err
        }

        mdb.metrics.Emit(stdout.Notice("Create record").
        With("query", query).
        With("error", err.Error()))

        return nil
    }

    query := bson.M{"publicID":publicID}
    queryData := bson.M({{ map .CreateAction "elem" "bson" "json" }})

    if err := database.C(mdb.col).Update(query, queryData); err != nil {
        mdb.metrics.Emit(stdout.Error("Failed to update {{.Struct.Object.Name}} record").
        With("query", query).
        With("error", err.Error()))
        return err
    }

    mdb.metrics.Emit(stdout.Notice("Update record").
    With("query", query).
    With("error", err.Error()))

    return nil
}